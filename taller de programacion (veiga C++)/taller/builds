/*
void Protocol::receive_builds(std::map <int, BuildClient*> &builds){
	builds.insert(std::pair<int, BuildClient*>(1, new WindTrap(skins.windTrapA, 0, 50, 0, 1, 100)));
}

#include <iostream>
#include <string>
#include <fstream>
#include <arpa/inet.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <cstring>
#include <typeinfo>
#include <tuple>
#include <map>
#include <vector>
#include <sstream>
#include <SFML/Graphics.hpp>
#include "common_build.h"
#include "common_windtrap.h"

using namespace sf;


WindTrap::WindTrap(std::map <int, Vector2f> &frames, float x, float y, int team, int id, int hp): BuildClient(x,y,team, id, hp), frames(frames) {
	this->largeBitsX = 65;
	this->largeBitsY = 75;
	this->is_constructed = false;
	this->frameWindow = 2;
	this->frameConstruction = 1;
	textBuild.loadFromFile("resources/builds/windtrap.png");
	spriteBuild.setTexture(textBuild);
	windows.setTexture(textBuild);
	Vector2f &posicionBuild = frames[frameBuild];
	spriteBuild.setTextureRect(IntRect(posicionBuild.x, posicionBuild.y,65,75));
	spriteBuild.setPosition(x,y);
	Vector2f &posicionWindow = frames[frameWindow];
	windows.setTextureRect(IntRect(posicionWindow.x, posicionWindow.y,40,55));
	windows.setPosition(x + 15,y + 7);		
}
	
void WindTrap::draw(RenderTarget &target, RenderStates states) const {
	if(is_selected){
		target.draw(lifeMax,states);
		target.draw(lifeRest,states);
	}
	if(is_constructed){
		target.draw(spriteBuild, states);
		target.draw(windows, states);
	} 
	if(frameConstruction > 1 && frameConstruction < 22){
		target.draw(spriteConstruction, states);
	}
}
	
void WindTrap::construct(){
	std::string f = "resources/builds/windtrap/" + std::to_string(frameConstruction) + ".bmp";
	Image image;
	image.loadFromFile(f);
	image.createMaskFromColor(sf::Color::Black);	
	textConstruction.loadFromImage(image);
	spriteConstruction.setTexture(textConstruction);
	spriteConstruction.setPosition(posX,posY);
	spriteConstruction.setTextureRect(IntRect(0,0,70,70));
	frameConstruction++;
	if(frameConstruction == 14) is_constructed = true;
	if(frameConstruction == 22) frameConstruction = 0;
}
	
void WindTrap::animateBuild(){
	if(cont % 10 == 0 && frameConstruction != 0) construct();
	if(cont % 50 == 0){
		if(frameWindow < 6) frameWindow++;
		else frameWindow = 2;
	}
	Vector2f &posicionBuild = frames[frameBuild];
	spriteBuild.setTextureRect(IntRect(posicionBuild.x, posicionBuild.y,65,75));
	Vector2f &posicionWindow = frames[frameWindow];
	windows.setTextureRect(IntRect(posicionWindow.x, posicionWindow.y,40,55));
	cont++;
}

WindTrap::~WindTrap(){}

#ifndef COMMON_WINDTRAP_H
#define COMMON_WINDTRAP_H
#include <vector>
#include <string>
#include <tuple>
#include <SFML/Graphics.hpp>
#include <time.h>
#include "common_build.h"
#include <SFML/Audio.hpp>

using namespace sf;


class WindTrap: public BuildClient{
	std::map <int, Vector2f> &frames;
    int frameWindow;
	bool is_constructed;
	Texture textBuild;
	Sprite spriteBuild;
	Sprite windows;
	Texture textConstruction;
	Sprite spriteConstruction;
	int frameConstruction;

	void construct();

	public:
	
	WindTrap(std::map <int, Vector2f> &frames, float x, float y, int team, int id, int hp);
	
	void draw(RenderTarget &target, RenderStates states) const;
		
	virtual void animateBuild() override;
	
    virtual ~WindTrap();


};


#endif
*/

#include <iostream>
#include <string>
#include <fstream>
#include <arpa/inet.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <cstring>
#include <typeinfo>
#include <tuple>
#include <map>
#include <vector>
#include <sstream>
#include <SFML/Graphics.hpp>
#include "common_build.h"

using namespace sf;


BuildClient::BuildClient(float x, float y, int team, int id, int hp): 
		is_selected(false), posX(x), posY(y), id(id), cont(0), frameBuild(1), hp(hp), hpMax(hp), team(team){
	lifeMax.setSize(Vector2f(70,3));
	lifeMax.setFillColor(sf::Color::Black);  
	int c = hp * 70 / hpMax;
	lifeRest.setSize(Vector2f(c,3));
	lifeRest.setFillColor(sf::Color::Green);
	lifeMax.setPosition(x, y - 8);
	lifeRest.setPosition(x, y - 8);		
}
	
void BuildClient::modifyHp(int new_hp){
	/*
		int life = hp * 70 / max_hp;
		lifeRest.setSize(Vector2f(life,3));
		int porcentual_life = hp * 100 / max_hp;
		if(porcentual_life < 30){
			lifeRest.setFillColor(sf::Color::Red);
			frameBuildClient = 0;
		} else {
			lifeRest.setFillColor(sf::Color::Green);
		}
		this->hp = new_hp;
		*/
}
	
bool BuildClient::is_there(float cord_x, float cord_y){
	int is_in = 0;
	if(this->posX <= cord_x && cord_x <= this->posX + this->largeBitsX) is_in += 1;
	if(this->posY <= cord_y && cord_y<= this->posY + this->largeBitsY) is_in += 1;
	return is_in == 2;
}

	
int BuildClient::get_team(){
	return team;
}
	
std::tuple<int, int, int, int> BuildClient::get_bits(){
	return std::make_tuple(posX, posY, largeBitsX, largeBitsY);
}
		
void BuildClient::selected_structure(){
    this->is_selected = true;
}

void BuildClient::deselected_structure(){
    this->is_selected = false;
}

int BuildClient::get_id_build(){
	return id;
}


void BuildClient::animateBuild(){}

void BuildClient::draw(RenderTarget &target, RenderStates states) const {}

#ifndef COMMON_BUILD_H
#define COMMON_BUILD_H
#include <vector>
#include <string>
#include <tuple>
#include <SFML/Graphics.hpp>
#include <time.h>
#include <SFML/Audio.hpp>

using namespace sf;


class BuildClient: public Drawable{
	public:
    bool is_selected;
	RectangleShape lifeMax;
	RectangleShape lifeRest;
	float posX;
	float posY;
	int id;
	int largeBitsX;
	int largeBitsY;
	int cont;
	int frameBuild;
	int hp;
	int hpMax;
	int team;

	BuildClient(float x, float y, int team, int id, int hp);

	void draw(RenderTarget &target, RenderStates states) const;
		
	void modifyHp(int new_hp);
	
	bool is_there(float cord_x, float cord_y);

    void selected_structure();

    void deselected_structure();
	
	int get_team();

	int get_id_build();
	
	std::tuple<int, int, int, int> get_bits();
	
	virtual void animateBuild();

};



#endif

void GameScreen::draw_builds(RenderWindow &window, Model &model, Camera &camera, int sizeX, int sizeY){
	for(auto iter = model.get_builds().begin(); iter != model.get_builds().end(); ++iter){
		std::tuple<int, int, int, int> uBits = iter->second->get_bits();
		iter->second->animateBuild();
		if(camera.appears_in_view(std::get<0>(uBits), std::get<1>(uBits), 
								std::get<2>(uBits), std::get<3>(uBits))){
			window.draw(*iter->second);
		}
	}
}
